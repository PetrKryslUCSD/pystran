window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pystran", "modulename": "pystran", "kind": "module", "doc": "<p>pystran - Python package for structural analysis with trusses and beams </p>\n\n<p>(C) 2025, Petr Krysl</p>\n"}, {"fullname": "pystran.assemble", "modulename": "pystran.assemble", "kind": "module", "doc": "<p>Define utility for assembling.</p>\n"}, {"fullname": "pystran.assemble.assemble", "modulename": "pystran.assemble", "qualname": "assemble", "kind": "function", "doc": "<p>Assemble local stiffness matrix <code>k</code> into global stiffness matrix <code>Kg</code>, using\nthe array of degrees of freedom, <code>dof</code>, for both the rows and columns.\nIn other words, <code>k</code> must be symmetric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Kg</span>, </span><span class=\"param\"><span class=\"n\">dof</span>, </span><span class=\"param\"><span class=\"n\">k</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam", "modulename": "pystran.beam", "kind": "module", "doc": "<p>Define beam mechanical quantities.</p>\n"}, {"fullname": "pystran.beam.beam_3d_xz_shape_fun", "modulename": "pystran.beam", "qualname": "beam_3d_xz_shape_fun", "kind": "function", "doc": "<p>Compute the beam shape functions for deflection in the <code>x-z</code> plane.</p>\n\n<p>An array of shape function values is returned (i.e. $[N_1(\\xi), ..., N_4(\\xi)]$).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_xz_shape_fun_xi2", "modulename": "pystran.beam", "qualname": "beam_3d_xz_shape_fun_xi2", "kind": "function", "doc": "<p>Compute the second derivative of the beam shape functions for deflection in\nthe <code>x-z</code> plane.</p>\n\n<p>An array of second derivatives of shape functions is returned (i.e.\n$[d^2N_1(\\xi)/d\\xi^2, ..., d^2N_4(\\xi)/d\\xi^2]$).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_xy_shape_fun", "modulename": "pystran.beam", "qualname": "beam_3d_xy_shape_fun", "kind": "function", "doc": "<p>Compute the beam shape functions for deflection in the x-y plane.</p>\n\n<p>The signs of the shape functions that go with the rotations (i.e. the second\nand fourth) need to be reversed: An array of second derivatives of shape\nfunctions is returned (i.e. $[N_1(\\xi), -N_2(\\xi),\nN_3(\\xi), -N_4(\\xi)]$).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_xy_shape_fun_xi2", "modulename": "pystran.beam", "qualname": "beam_3d_xy_shape_fun_xi2", "kind": "function", "doc": "<p>Compute the second derivative of the beam shape functions for deflection in\nthe <code>x-y</code> plane.</p>\n\n<p>The signs of the shape functions that go with the rotations (i.e. the second\nand fourth) need to be reversed: An array of second derivatives of shape\nfunctions is returned (i.e. $[d^2N_1(\\xi)/d\\xi^2, -d^2N_2(\\xi)/d\\xi^2,\nd^2N_3(\\xi)/d\\xi^2, -d^2N_4(\\xi)/d\\xi^2]$).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_xz_shape_fun_xi3", "modulename": "pystran.beam", "qualname": "beam_3d_xz_shape_fun_xi3", "kind": "function", "doc": "<p>Compute the third derivative of the beam shape functions with respect to\n<code>xi</code> for deflection in the <code>x-z</code> plane.</p>\n\n<p>An array of third derivatives of shape functions is returned (i.e.\n$[d^3N_1(\\xi)/d\\xi^3, ..., d^3N_4(\\xi)/d\\xi^3]$).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_xy_shape_fun_xi3", "modulename": "pystran.beam", "qualname": "beam_3d_xy_shape_fun_xi3", "kind": "function", "doc": "<p>Compute the third derivative of the beam shape functions with respect to\n<code>xi</code> for deflection in the <code>x-y</code> plane.</p>\n\n<p>The signs of the shape functions that go with the rotations (i.e. the second\nand fourth) need to be reversed: An array of third derivatives of shape\nfunctions is returned (i.e. $[d^3N_1(\\xi)/d\\xi^3, -d^3N_2(\\xi)/d\\xi^3,\nd^3N_3(\\xi)/d\\xi^3, -d^3N_4(\\xi)/d\\xi^3]$).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_2d_bending_stiffness", "modulename": "pystran.beam", "qualname": "beam_2d_bending_stiffness", "kind": "function", "doc": "<p>Compute 2d beam stiffness matrix.</p>\n\n<p>Two-point Gauss quadrature is used to compute the stiffness matrix.</p>\n\n<p>The formula reads</p>\n\n<p>$K = (h/2) \\int_{-1}^{+1} EI_y B^T B  d\\xi$,</p>\n\n<p>where $B$ is the curvature-displacement matrix (computed by\n<code>beam_2d_curv_displ_matrix</code>), and $h/2$ is the Jacobian. <code>I_y</code> is the second\nmoment of area about the <code>y</code> axis (which is orthogonal to the plane of\nbending).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">E</span>, </span><span class=\"param\"><span class=\"n\">I_y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_xz_curv_displ_matrix", "modulename": "pystran.beam", "qualname": "beam_3d_xz_curv_displ_matrix", "kind": "function", "doc": "<p>Compute beam curvature-displacement matrix in the local <code>x-z</code> plane (i.e.\nbending about the <code>y</code> axis).</p>\n\n<p>The curvature $d^2w/dx^2$ is computed in the local coordinate system of the\nbeam as $d^2w/dx^2 = B U$. Here $B$ is the curvature-displacement matrix and\n$U$ is the displacement vector. All three displacement components and all\nthree rotation components at each joint are assumed, so the matrix $B$ has\none row and twelve columns.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_y</span>, </span><span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_xy_curv_displ_matrix", "modulename": "pystran.beam", "qualname": "beam_3d_xy_curv_displ_matrix", "kind": "function", "doc": "<p>Compute beam curvature-displacement matrix in the local <code>x-y</code> plane (i.e.\nbending about the <code>z</code> axis).</p>\n\n<p>The curvature $d^2v/dx^2$ is computed in the local coordinate system of the\nbeam as $d^2v/dx^2 = B U$. Here $B$ is the curvature-displacement matrix and\n$U$ is the displacement vector. All three displacement components and all\nthree rotation components at each joint are assumed, so the matrix $B$ has\none row and twelve columns.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_y</span>, </span><span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_bending_stiffness", "modulename": "pystran.beam", "qualname": "beam_3d_bending_stiffness", "kind": "function", "doc": "<p>Compute 3d beam stiffness matrices for bending in the planes <code>x-y</code> and\n<code>x-z</code>.</p>\n\n<p>Two-point Gauss quadrature is used to compute the stiffness matrices.</p>\n\n<p>The formula reads</p>\n\n<p>$K = (h/2) \\int_{-1}^{+1} EI_y B_{xz}^T B_{xz}  d\\xi$,</p>\n\n<p>for bending in the <code>x-z</code> plane, and</p>\n\n<p>$K = (h/2) \\int_{-1}^{+1} EI_z B_{xy}^T B_{xy}  d\\xi$,</p>\n\n<p>where $B_{xz}$ is the curvature-displacement matrix for bending in the <code>x-z</code>\nplane (computed by <code>beam_3d_xz_curv_displ_matrix</code>), $B_{xy}$ is the\ncurvature-displacement matrix for bending in the <code>x-y</code> plane (computed by\n<code>beam_3d_xy_curv_displ_matrix</code>), and $h/2$ is the Jacobian. <code>I_y</code> is the\nsecond moment of area about the <code>y</code> axis, and <code>I_z</code>  is the second moment of\narea about the <code>z</code> axis.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_y</span>, </span><span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">E</span>, </span><span class=\"param\"><span class=\"n\">Iy</span>, </span><span class=\"param\"><span class=\"n\">Iz</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_2d_curv_displ_matrix", "modulename": "pystran.beam", "qualname": "beam_2d_curv_displ_matrix", "kind": "function", "doc": "<p>Compute 2d beam curvature-displacement matrix.</p>\n\n<p>Here the curvatures is with respect to the physical coordinate measured\nalong the member (local <code>x</code>).</p>\n\n<p>The curvature $d^2w/dx^2$ is computed in the local coordinate system of the\nbeam as $d^2w/dx^2 = B U$. Here $B$ is the curvature-displacement matrix and\n$U$ is the displacement vector. Two displacement components and one rotation\ncomponent at each joint are assumed, so the matrix $B$ has one row and six\ncolumns.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_2d_3rd_deriv_displ_matrix", "modulename": "pystran.beam", "qualname": "beam_2d_3rd_deriv_displ_matrix", "kind": "function", "doc": "<p>Compute beam third derivative-displacement matrix.</p>\n\n<p>Here the third derivative is with respect to the physical coordinate measured\nalong the member (local <code>x</code>).</p>\n\n<p>The third derivative $d^3w/dx^3$ is computed in the local coordinate system of the\nbeam as $d^3w/dx^3 = B U$. Here $B$ is the third-derivative-displacement matrix and\n$U$ is the displacement vector. Two displacement components and one rotation\ncomponent at each joint are assumed, so the matrix $B$ has one row and six\ncolumns.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_xz_3rd_deriv_displ_matrix", "modulename": "pystran.beam", "qualname": "beam_3d_xz_3rd_deriv_displ_matrix", "kind": "function", "doc": "<p>Compute 3d beam third derivative-displacement matrix for displacements in\nthe <code>x-z</code> plane.</p>\n\n<p>Here the third derivative is with respect to the physical coordinate measured\nalong the member (local <code>x</code>).</p>\n\n<p>The third derivative $d^3w/dx^3$ is computed in the local coordinate system of the\nbeam as $d^3w/dx^3 = B U$. Here $B$ is the third-derivative-displacement matrix and\n$U$ is the displacement vector. All three displacement components and all\nthree rotation components at each joint are assumed, so the matrix $B$ has\none row and twelve columns.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_y</span>, </span><span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_xy_3rd_deriv_displ_matrix", "modulename": "pystran.beam", "qualname": "beam_3d_xy_3rd_deriv_displ_matrix", "kind": "function", "doc": "<p>Compute 3d beam third derivative-displacement matrix for displacements in\nthe <code>x-y</code> plane.</p>\n\n<p>Here the third derivative is with respect to the physical coordinate measured\nalong the member (local <code>x</code>).</p>\n\n<p>The third derivative $d^3v/dx^3$ is computed in the local coordinate system of the\nbeam as $d^3v/dx^3 = B U$. Here $B$ is the third-derivative-displacement matrix and\n$U$ is the displacement vector. All three displacement components and all\nthree rotation components at each joint are assumed, so the matrix $B$ has\none row and twelve columns.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_y</span>, </span><span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_2d_moment", "modulename": "pystran.beam", "qualname": "beam_2d_moment", "kind": "function", "doc": "<p>Compute 2d beam moment based on the displacements stored at the joints.\nThe moment is computed at the parametric location <code>xi</code> along the beam.</p>\n\n<p>The moment is mathematically defined as $M = -EI d^2w/dx^2$.</p>\n\n<p>The curvature is computed with the curvature-displacement matrix $B$ by the function\n<code>beam_2d_curv_displ_matrix</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_moment", "modulename": "pystran.beam", "qualname": "beam_3d_moment", "kind": "function", "doc": "<p>Compute 3d beam moment based on the displacements stored at the joints. The\nmoment is computed at the parametric location <code>xi</code> along the beam. The\nmoment acts about the axis specified by the string <code>axis</code> (<code>'y'</code> or <code>'z'</code>).</p>\n\n<p>The moments are mathematically defined as $M_y = -EI_y d^2w/dx^2$ for\nbending about the <code>y</code> axis, and $M_z = +EI_z d^2v/dx^2$ for bending about\nthe <code>z</code> axis.</p>\n\n<p>The curvatures are computed with  curvature-displacement matrices $B$ by the\nfunctions <code>beam_3d_xz_curv_displ_matrix</code> and <code>beam_3d_xy_curv_displ_matrix</code>,\nrespectively.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">axis</span>, </span><span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_torsion_moment", "modulename": "pystran.beam", "qualname": "beam_3d_torsion_moment", "kind": "function", "doc": "<p>Compute 3d beam torsion moment based on the displacements stored at the\njoints. The moment is uniform along the beam.</p>\n\n<p>The moment is mathematically defined as $T = GJ d\\theta_x/dx$. The rate of\nchange of the axial rotation, $d\\theta_x/dx$, is computed with the\ntorsion-displacement matrix $B$, obtained by the function\n<code>beam_3d_torsion_displ_matrix</code>.</p>\n\n<p>The torsion moment is uniform along the beam.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_2d_axial_force", "modulename": "pystran.beam", "qualname": "beam_2d_axial_force", "kind": "function", "doc": "<p>Compute 2d beam axial force based on the displacements stored at the joints.</p>\n\n<p>Refer to the function <code>truss.truss_strain_displacement</code> that computes the\nstrain-displacement matrix for a truss member.</p>\n\n<p>The axial force is uniform along the beam.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_axial_force", "modulename": "pystran.beam", "qualname": "beam_3d_axial_force", "kind": "function", "doc": "<p>Compute 3d beam axial force based on the displacements stored at the joints.</p>\n\n<p>The axial force is uniform along the beam.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_shear_force", "modulename": "pystran.beam", "qualname": "beam_3d_shear_force", "kind": "function", "doc": "<p>Compute 3d shear force based on the displacements stored at the joints. The\nshear force in the direction of axis <code>axis</code>  (<code>'y'</code> or <code>'z'</code>) is uniform along the beam.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">axis</span>, </span><span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_2d_shear_force", "modulename": "pystran.beam", "qualname": "beam_2d_shear_force", "kind": "function", "doc": "<p>Compute 2d beam shear force based on the displacements stored at the joints.\nThe shear force is computed at the parametric location <code>xi</code> along the beam.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_stretch_displ_matrix", "modulename": "pystran.beam", "qualname": "beam_3d_stretch_displ_matrix", "kind": "function", "doc": "<p>Compute beam stretch-displacement matrix.</p>\n\n<p>Stretch here means axial strain.</p>\n\n<p>The job is delegated to the truss module.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_x</span>, </span><span class=\"param\"><span class=\"n\">h</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_2d_3d_axial_stiffness", "modulename": "pystran.beam", "qualname": "beam_2d_3d_axial_stiffness", "kind": "function", "doc": "<p>Compute axial stiffness matrix.</p>\n\n<p>This function works both for 2D and 3D beams.</p>\n\n<p>The axial stiffness matrix is computed as $K = EA B^T B h$. Here $B$ is the\nstretch-displacement matrix, computed by <code>beam_3d_stretch_displ_matrix</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_x</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">E</span>, </span><span class=\"param\"><span class=\"n\">A</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_torsion_stiffness", "modulename": "pystran.beam", "qualname": "beam_3d_torsion_stiffness", "kind": "function", "doc": "<p>Compute torsion stiffness matrix.</p>\n\n<p>The torsion stiffness matrix is computed as $K = GJ B^T B h$. Here $B$ is\nthe torsion-displacement matrix, computed by <code>beam_3d_torsion_displ_matrix</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_x</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">G</span>, </span><span class=\"param\"><span class=\"n\">J</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_torsion_displ_matrix", "modulename": "pystran.beam", "qualname": "beam_3d_torsion_displ_matrix", "kind": "function", "doc": "<p>Compute torsion-displacement matrix.</p>\n\n<p>The torsion-displacement matrix is constant.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_x</span>, </span><span class=\"param\"><span class=\"n\">h</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.assemble_stiffness", "modulename": "pystran.beam", "qualname": "assemble_stiffness", "kind": "function", "doc": "<p>Assemble beam stiffness matrix.</p>\n\n<p>Beam is here considered as a superposition of four mechanisms  -- axial bar,\ntorsion bar, bending in the <code>x-y</code> plane, and bending in the <code>x-z</code> plane.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Kg</span>, </span><span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.assemble_mass", "modulename": "pystran.beam", "qualname": "assemble_mass", "kind": "function", "doc": "<p>Assemble beam mass matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Mg</span>, </span><span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_2d_mass", "modulename": "pystran.beam", "qualname": "beam_2d_mass", "kind": "function", "doc": "<p>Compute beam mass matrix.</p>\n\n<p>The mass matrix is consistent, which means that it is computed as discrete\nform of the kinetic energy of the element,</p>\n\n<p>$\\int \\rho A \\left(\\dot u \\cdot \\dot u +  \\dot w \\cdot \\dot\nw\\right)dx$</p>\n\n<p>where $\\dot u$ and $\\dot w$ are the velocities in the $x$ and $z$\ndirections.</p>\n\n<p>The velocity $\\dot u$ is assumed to very linearly along the element, and\nthe velocity $\\dot w$ is assumed to vary according to the Hermite shape\nfunctions.</p>\n\n<p>Gauss quadrature is used to compute the mass matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_x</span>, </span><span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">I</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_mass", "modulename": "pystran.beam", "qualname": "beam_3d_mass", "kind": "function", "doc": "<p>Compute beam mass matrix.</p>\n\n<p>The mass matrix is consistent, which means that it is computed as discrete\nform of the kinetic energy of the element,</p>\n\n<p>$\\int \\rho A \\left(\\dot u \\cdot \\dot u + \\dot v \\cdot \\dot v + \\dot w \\cdot \\dot\nw\\right)dx$</p>\n\n<p>where $\\dot u$, $\\dot v$, and $\\dot w$ are the velocities in the $x$, $y$, and $z$\ndirections.</p>\n\n<p>The velocity $\\dot u$ is assumed to very linearly along the element, and\nthe velocity $\\dot v$, $\\dot w$ is assumed to vary according to the Hermite shape\nfunctions. Rotations about $y$ and $z$ are ignored in the kinetic energy.</p>\n\n<p>For spinning of the beam about its axis, the kinetic energy is given by the formula</p>\n\n<p>$\\int \\rho Ix \\dot \\theta_x \\cdot \\dot \\theta_x dx$.</p>\n\n<p>Gauss quadrature is used to compute the mass matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_x</span>, </span><span class=\"param\"><span class=\"n\">e_y</span>, </span><span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">Ix</span>, </span><span class=\"param\"><span class=\"n\">Iy</span>, </span><span class=\"param\"><span class=\"n\">Iz</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_3d_end_forces", "modulename": "pystran.beam", "qualname": "beam_3d_end_forces", "kind": "function", "doc": "<p>Compute the end forces of a beam element in 3d.</p>\n\n<p>The end forces of the beam are forces acting on the joints <code>i</code> and <code>j</code> by the beam.</p>\n\n<p>Dictionary with the keys <code>'Ni'</code>, <code>'Qyi'</code>, <code>'Qzi'</code>, <code>'Ti'</code>, <code>'Myi'</code>, <code>'Mzi'</code>, <code>'Nj'</code>,\n<code>'Qyj'</code>, <code>'Qzj'</code>, <code>'Tj'</code>, <code>'Myj'</code>, <code>'Mzj'</code>,  is returned.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.beam.beam_2d_end_forces", "modulename": "pystran.beam", "qualname": "beam_2d_end_forces", "kind": "function", "doc": "<p>Compute the end forces of a beam element in 3d.</p>\n\n<p>The end forces of the beam are forces acting on the joints <code>i</code> and <code>j</code> by\n the beam.</p>\n\n<p>Dictionary with the keys <code>'Ni'</code>, <code>'Qzi'</code>, <code>'Myi'</code>,  <code>'Nj'</code>,\n<code>'Qzj'</code>,  <code>'Myj'</code>,  is returned.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.gauss", "modulename": "pystran.gauss", "kind": "module", "doc": "<p>Define numerical integration rules.</p>\n"}, {"fullname": "pystran.gauss.rule", "modulename": "pystran.gauss", "qualname": "rule", "kind": "function", "doc": "<p>Set up Gauss quadrature points and weights for a given number of points.</p>\n\n<p>The number of points can be varied between 1 and 7.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">numpts</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.geometry", "modulename": "pystran.geometry", "kind": "module", "doc": "<p>Simple geometry utilities.</p>\n"}, {"fullname": "pystran.geometry.delt", "modulename": "pystran.geometry", "qualname": "delt", "kind": "function", "doc": "<p>Compute oriented vector from the first to the second joint</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span>, </span><span class=\"param\"><span class=\"n\">xj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.geometry.vlen", "modulename": "pystran.geometry", "qualname": "vlen", "kind": "function", "doc": "<p>Compute distance from the first to the second joint</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span>, </span><span class=\"param\"><span class=\"n\">xj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.geometry.lin_basis", "modulename": "pystran.geometry", "qualname": "lin_basis", "kind": "function", "doc": "<p>Compute linear basis functions for an interval $-1\\le\\xi\\le+1$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.geometry.interpolate", "modulename": "pystran.geometry", "qualname": "interpolate", "kind": "function", "doc": "<p>Interpolate linearly between two quantities.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span>, </span><span class=\"param\"><span class=\"n\">x1</span>, </span><span class=\"param\"><span class=\"n\">x2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.geometry.herm_basis", "modulename": "pystran.geometry", "qualname": "herm_basis", "kind": "function", "doc": "<p>Compute the Hermite basis functions.</p>\n\n<p>An array of basis function values is returned (i.e. $[N_1(\\xi), ..., N_4(\\xi)]$).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.geometry.herm_basis_xi", "modulename": "pystran.geometry", "qualname": "herm_basis_xi", "kind": "function", "doc": "<p>Compute the first derivative wrt $\\xi$ of the Hermite basis functions.</p>\n\n<p>An array of first derivatives of shape functions is returned (i.e.\n$[dN_1(\\xi)/d\\xi, ..., dN_4(\\xi)/d\\xi]$).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.geometry.herm_basis_xi2", "modulename": "pystran.geometry", "qualname": "herm_basis_xi2", "kind": "function", "doc": "<p>Compute the second derivative wrt $\\xi$ of the Hermite basis functions.</p>\n\n<p>An array of second derivatives of shape functions is returned (i.e.\n$[d^2N_1(\\xi)/d\\xi^2, ..., d^2N_4(\\xi)/d\\xi^2]$).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.geometry.herm_basis_xi3", "modulename": "pystran.geometry", "qualname": "herm_basis_xi3", "kind": "function", "doc": "<p>Compute the third derivative wrt $\\xi$ of the Hermite basis functions.</p>\n\n<p>An array of third derivatives of shape functions is returned (i.e.\n$[d^3N_1(\\xi)/d\\xi^3, ..., d^3N_4(\\xi)/d\\xi^3]$).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.geometry.member_2d_geometry", "modulename": "pystran.geometry", "qualname": "member_2d_geometry", "kind": "function", "doc": "<p>Compute 2d member geometry.</p>\n\n<p>A local coordinate system is attached to the member such that the <code>x</code> axis is\nalong the member axis. The deformation of the member is considered in the x-z\nplane.</p>\n\n<p>Vector <code>e_x</code> is the direction vector along the axis of the member. <code>e_z</code> is\nthe direction vector perpendicular to the axis of the member. These two\nvectors form a left-handed coordinate system (consistent with the sign\nconvention in the book): The deflection <code>w</code> is measured positive downwards,\nwhile the <code>x</code> coordinate is measured left to right. So in two dimensions\n<code>e_x</code> and <code>e_z</code> form a left-handed coordinate system. In reality, the\ncomplete coordinate system is right-handed, as the not-used basis vector is\n<code>e_y</code>, which points out of the plane of the screen (page).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.geometry.member_3d_geometry", "modulename": "pystran.geometry", "qualname": "member_3d_geometry", "kind": "function", "doc": "<p>Compute 3d member geometry.</p>\n\n<p>A local coordinate system is attached to the member such that the <code>x</code> axis\nis along the member axis. The deformation of the member is considered in the\n<code>x-y</code> and <code>x-z</code> plane.</p>\n\n<p>Vector <code>e_x</code> is the direction vector along the axis of the member. <code>e_z</code> is\nthe direction vector perpendicular to the axis of the member. These two\nvectors form a right-handed coordinate system, completed by <code>e_y</code>.</p>\n\n<p>The plane <code>x-z</code> is defined by the vector <code>xz_vector</code> and the member axis\n(i.e. <code>e_x</code>). Therefore, the vector <code>xz_vector</code> must not be parallel to the\nmember axis.</p>\n\n<ul>\n<li><code>i</code> and <code>j</code> = the two joints of the member.</li>\n<li><code>xz_vector</code> = the vector that defines the <code>x-z</code> plane of the member-local\ncoordinate system. It does not need to be of unit length, but it must not\nbe parallel to the member axis. This vector is not defined for a truss\nmember, and will be passed in as empty. Heuristics will be then used to\norient the planes.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">xz_vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model", "modulename": "pystran.model", "kind": "module", "doc": "<p>Define the functions for defining and manipulating a model.</p>\n"}, {"fullname": "pystran.model.U1", "modulename": "pystran.model", "qualname": "U1", "kind": "variable", "doc": "<p>This is a designation of the degree of freedom as translation along <code>X</code>.</p>\n", "default_value": "0"}, {"fullname": "pystran.model.U2", "modulename": "pystran.model", "qualname": "U2", "kind": "variable", "doc": "<p>This is a designation of the degree of freedom as translation along <code>Z</code> (in 2D models)\nor along <code>Y</code> (in 3D models).</p>\n", "default_value": "1"}, {"fullname": "pystran.model.U3", "modulename": "pystran.model", "qualname": "U3", "kind": "variable", "doc": "<p>This is a designation of the degree of freedom as translation along <code>Z</code> (in 3D models).</p>\n", "default_value": "2"}, {"fullname": "pystran.model.UR1", "modulename": "pystran.model", "qualname": "UR1", "kind": "variable", "doc": "<p>This is a designation of the degree of freedom as rotation about  <code>X</code> (in 3D models).</p>\n", "default_value": "3"}, {"fullname": "pystran.model.UR2", "modulename": "pystran.model", "qualname": "UR2", "kind": "variable", "doc": "<p>This is a designation of the degree of freedom as rotation about  <code>Y</code> (in 3D models).</p>\n", "default_value": "4"}, {"fullname": "pystran.model.UR3", "modulename": "pystran.model", "qualname": "UR3", "kind": "variable", "doc": "<p>This is a designation of the degree of freedom as rotation about  <code>Y</code> (in 2D\nmodels) or rotation about <code>Z</code>  (in 3D models).</p>\n", "default_value": "5"}, {"fullname": "pystran.model.ALL_DOFS", "modulename": "pystran.model", "qualname": "ALL_DOFS", "kind": "variable", "doc": "<p>This is a designation of all the degrees of freedom, translations and rotations\n(<code>U1</code>, <code>U2</code>, <code>UR3</code> in 2D models, or <code>U1</code>, <code>U2</code>, <code>U3</code>, <code>UR1</code>, <code>UR2</code>, <code>UR3</code> in 3D\nmodels). It may be used to specify the clamped condition for the joint.</p>\n", "default_value": "100"}, {"fullname": "pystran.model.TRANSLATION_DOFS", "modulename": "pystran.model", "qualname": "TRANSLATION_DOFS", "kind": "variable", "doc": "<p>This is a designation of the translation degrees of freedom (<code>U1</code>, <code>U2</code>,  in 2D\nmodels, or <code>U1</code>, <code>U2</code>,  <code>U3</code> in 3D models). It may be used to specify the pinned\ncondition for the joint.</p>\n", "default_value": "200"}, {"fullname": "pystran.model.create", "modulename": "pystran.model", "qualname": "create", "kind": "function", "doc": "<p>Create a new model.</p>\n\n<p>Supply the dimension of the model (2 or 3).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.add_joint", "modulename": "pystran.model", "qualname": "add_joint", "kind": "function", "doc": "<p>Add a joint to the model.</p>\n\n<ul>\n<li><code>m</code> = the model,</li>\n<li><code>jid</code> = the joint identifier,</li>\n<li><code>coordinates</code> = the list of coordinates of the joint.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">jid</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.add_truss_member", "modulename": "pystran.model", "qualname": "add_truss_member", "kind": "function", "doc": "<p>Add a truss member to the model.</p>\n\n<ul>\n<li><code>m</code> = the model,</li>\n<li><code>mid</code> = the member identifier (must be unique),</li>\n<li><code>connectivity</code> = the list of the joint identifiers,</li>\n<li><code>sect</code> = the section of the member.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">mid</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">connectivity</span>, </span><span class=\"param\"><span class=\"n\">sect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.add_beam_member", "modulename": "pystran.model", "qualname": "add_beam_member", "kind": "function", "doc": "<p>Add a beam member to the model.</p>\n\n<ul>\n<li><code>m</code> = the model,</li>\n<li><code>mid</code> = the member identifier (must be unique),</li>\n<li><code>connectivity</code> = the list of the joint identifiers,</li>\n<li><code>sect</code> = the section of the member.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">mid</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">connectivity</span>, </span><span class=\"param\"><span class=\"n\">sect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.add_support", "modulename": "pystran.model", "qualname": "add_support", "kind": "function", "doc": "<p>Add a support to a joint.</p>\n\n<ul>\n<li><code>j</code> = the joint,</li>\n<li><code>dof</code> = the degree of freedom,</li>\n<li><code>value</code> = the amount of the support motion (default is zero).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">dof</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.add_load", "modulename": "pystran.model", "qualname": "add_load", "kind": "function", "doc": "<p>Add a load to a joint.</p>\n\n<ul>\n<li><code>j</code> = the joint,</li>\n<li><code>dof</code> = the degree of freedom,</li>\n<li><code>value</code> = signed magnitude of the load.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">dof</span>, </span><span class=\"param\"><span class=\"n\">value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.add_mass", "modulename": "pystran.model", "qualname": "add_mass", "kind": "function", "doc": "<p>Add a mass to a joint.</p>\n\n<ul>\n<li><code>j</code> = the joint,</li>\n<li><code>dof</code> = the degree of freedom,</li>\n<li><code>value</code> = magnitude of the mass.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">dof</span>, </span><span class=\"param\"><span class=\"n\">value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.add_links", "modulename": "pystran.model", "qualname": "add_links", "kind": "function", "doc": "<p>Add links between all joints in the list <code>jids</code> in the direction <code>dof</code>.</p>\n\n<ul>\n<li><code>m</code> = the model,</li>\n<li><code>jids</code> = the list of joint identifiers,</li>\n<li><code>dof</code> = the degree of freedom at which the joints are to be linked.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">jids</span>, </span><span class=\"param\"><span class=\"n\">dof</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.bounding_box", "modulename": "pystran.model", "qualname": "bounding_box", "kind": "function", "doc": "<p>Compute the bounding box of the model.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.characteristic_dimension", "modulename": "pystran.model", "qualname": "characteristic_dimension", "kind": "function", "doc": "<p>Compute the characteristic dimension of the model.</p>\n\n<p>This is the average of the dimensions of the bounding box.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.ndof_per_joint", "modulename": "pystran.model", "qualname": "ndof_per_joint", "kind": "function", "doc": "<p>How many degrees of freedom are there per joint?</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.number_dofs", "modulename": "pystran.model", "qualname": "number_dofs", "kind": "function", "doc": "<p>Number degrees of freedom.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.solve_statics", "modulename": "pystran.model", "qualname": "solve_statics", "kind": "function", "doc": "<p>Solve the static equilibrium of the discrete model.</p>\n\n<p><code>number_dofs</code> must be called before this function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.statics_reactions", "modulename": "pystran.model", "qualname": "statics_reactions", "kind": "function", "doc": "<p>Compute the reactions in the static equilibrium of the discrete model.</p>\n\n<p>The static solution must be obtained with <code>solve_statics</code> before calling\nthis function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.solve_free_vibration", "modulename": "pystran.model", "qualname": "solve_free_vibration", "kind": "function", "doc": "<p>Solve the free vibration of the discrete model.</p>\n\n<p>The free vibration eigenvalue problem is solved for the eigenvalues and\neigenvectors (can be retrieved as  <code>m[\"eigvals\"]</code> and <code>m[\"eigvecs\"]</code>). The\nfrequencies are computed from the eigenvalues (can be retrieved as\n<code>m[\"frequencies\"]</code>).</p>\n\n<p><code>number_dofs</code> must be called before this function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.copy_mode", "modulename": "pystran.model", "qualname": "copy_mode", "kind": "function", "doc": "<p>Copy a mode to the displacement field of the model.</p>\n\n<p><code>solve_free_vibration</code> must be called before this function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">mode</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.free_body_check", "modulename": "pystran.model", "qualname": "free_body_check", "kind": "function", "doc": "<p>Check the balance of the structure as a free body.</p>\n\n<p>All the active forces and moments together with the reactions at all the\nsupports should sum to zero.</p>\n\n<p><code>statics_reactions</code> must be called before this function as this calculation\nrelies on the presence of reactions at the joints.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.model.refine_member", "modulename": "pystran.model", "qualname": "refine_member", "kind": "function", "doc": "<p>Refine a beam member by replacing it with <code>n</code> new members.</p>\n\n<p>The new joints are numbered starting from the maximum joint identifier in\nthe model.</p>\n\n<ul>\n<li><code>m</code> = the model,</li>\n<li><code>mid</code> = the member identifier,</li>\n<li><code>n</code> = the number of new beam members to replace the old member with.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">mid</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots", "modulename": "pystran.plots", "kind": "module", "doc": "<p>Implement simple plots for truss and beam structures.</p>\n"}, {"fullname": "pystran.plots.plot_setup", "modulename": "pystran.plots", "qualname": "plot_setup", "kind": "function", "doc": "<p>Setup the plot.</p>\n\n<p>This function creates a figure and an axis object. The axes are returned.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">set_limits</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_members", "modulename": "pystran.plots", "qualname": "plot_members", "kind": "function", "doc": "<p>Plot the members of the structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_deformations", "modulename": "pystran.plots", "qualname": "plot_deformations", "kind": "function", "doc": "<p>Plot the deformations in the truss and beam members.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_member_numbers", "modulename": "pystran.plots", "qualname": "plot_member_numbers", "kind": "function", "doc": "<p>Plot the member numbers.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_joint_numbers", "modulename": "pystran.plots", "qualname": "plot_joint_numbers", "kind": "function", "doc": "<p>Plot the joint numbers.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_bending_moments", "modulename": "pystran.plots", "qualname": "plot_bending_moments", "kind": "function", "doc": "<p>Plot the bending moments in the beam members.</p>\n\n<p>Optional: axis = \"y\" or \"z\" (default is \"y\", which is suitable for 2d beams).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;y&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_shear_forces", "modulename": "pystran.plots", "qualname": "plot_shear_forces", "kind": "function", "doc": "<p>Plot the shear forces in the beam members.</p>\n\n<p>Optional: axis = \"y\" or \"z\" (default is \"z\", which is suitable for 2d beams).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;z&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_axial_forces", "modulename": "pystran.plots", "qualname": "plot_axial_forces", "kind": "function", "doc": "<p>Plot the axial forces in the members.</p>\n\n<p>Optional: axis = \"y\" or \"z\" (default is \"z\", which is suitable for 2d beams).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_torsion_moments", "modulename": "pystran.plots", "qualname": "plot_torsion_moments", "kind": "function", "doc": "<p>Plot the torsion moments in the 3D beam members.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_beam_orientation", "modulename": "pystran.plots", "qualname": "plot_beam_orientation", "kind": "function", "doc": "<p>Plot the beam orientations as cartesian triplets.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_applied_forces", "modulename": "pystran.plots", "qualname": "plot_applied_forces", "kind": "function", "doc": "<p>Plot the applied forces at the joints.</p>\n\n<ul>\n<li><code>m</code> = model dictionary,</li>\n<li><code>scale</code> = scale factor for the arrows.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_applied_moments", "modulename": "pystran.plots", "qualname": "plot_applied_moments", "kind": "function", "doc": "<p>Plot the applied moments at the joints.</p>\n\n<ul>\n<li><code>m</code> = model dictionary,</li>\n<li><code>scale</code> = scale factor for the arrows. Moments are rendered with double\narrows.</li>\n</ul>\n\n<p>Optional: <code>radius</code> = radius of the circle (2D only).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_translation_supports", "modulename": "pystran.plots", "qualname": "plot_translation_supports", "kind": "function", "doc": "<p>Plot the translation supports at the joints.</p>\n\n<ul>\n<li><code>m</code> = model dictionary,</li>\n<li><code>scale</code> = scale factor for the arrows.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">shortest_arrow</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.plot_rotation_supports", "modulename": "pystran.plots", "qualname": "plot_rotation_supports", "kind": "function", "doc": "<p>Plot the rotation supports at the joints.</p>\n\n<ul>\n<li><code>m</code> = model dictionary,</li>\n<li><code>scale</code> = scale factor for the arrows. Moments are rendered with double\narrows.</li>\n</ul>\n\n<p>Optional: <code>radius</code> = radius of the circle (2D only).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">shortest_arrow</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.plots.show", "modulename": "pystran.plots", "qualname": "show", "kind": "function", "doc": "<p>Show the plot.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.pystran", "modulename": "pystran.pystran", "kind": "module", "doc": "<p>pystran - Python package for structural analysis with trusses and beams </p>\n\n<p>(C) 2025, Petr Krysl</p>\n\n<p>This package is intended for educational purposes only. Professional users may\nfind it too bare bones.</p>\n\n<p>The approach is based on classical weighted residual formulation (Galerkin). The\nformulations are derived in the \"Finite element modeling with shells and beams\"\n<a href=\"http://hogwarts.ucsd.edu/~pkrysl/femstructures-book/\">book</a>.</p>\n\n<p>The approach here is modern as opposed to classic.</p>\n\n<p>Classically, the geometrical transformations are developed explicitly to push\nthe stiffness and mass matrices from special orientations to the real\norientation in space. This requires multiplication of the stiffness and mass\nmatrices by large transformation matrices on the left and right. The matrices in\nspecial orientations are usually developed analytically, and these explicit\nexpressions become the starting point for developing computations. So for\ninstance for spatial beams, the starting point are 12x12 matrices.</p>\n\n<p>The modern approach develops an expression for the strains in a basic element,\nfor instance curvature in beams. This leads to a small basic stiffness matrix,\n4x4 matrix in the case of a 2D beam. The geometrical transformation is then\nintroduced implicitly by projecting displacements in the real space onto the\nlocal basis vectors of the element. The Galerkin weighted residual method then\nnaturally completes the development of the matrices.</p>\n\n<p>The three dimensional beam is in such a modern framework treated as a\nsuperposition of four stiffness mechanisms, each with its own\nstrain-displacement matrix. The stiffness and mass matrices are obtained readily\nusing numerical integration.</p>\n\n<h2 id=\"features-and-limitations\">Features and limitations</h2>\n\n<ul>\n<li>Two-dimensional and three-dimensional structures made up of truss (axial)\nmembers and beams (even in combination) can be handled.</li>\n<li>The Bernoulli-Euler model is implemented, so no shear deformation is taken\ninto account.</li>\n<li>Only elastic models can be solved.</li>\n<li>Only straight members are treated.</li>\n<li>Only doubly symmetric cross sections can be handled in three dimensions. Hence\nthere is no coupling between the bending actions in the two orthogonal planes.</li>\n<li>Warping of the cross sections is not modelled, hence only free torsion effects\nare included.</li>\n<li>Member loading is not considered. All member loading needs to be converted to\nnodal forces.</li>\n<li>Internal hinges can be modelled with linked joints. No member end releases are\nimplemented.</li>\n<li>Degrees of freedom are only along the cartesian axes. Skew supports are not\nincluded.</li>\n<li>Offsets are currently not implemented.</li>\n</ul>\n"}, {"fullname": "pystran.rotation", "modulename": "pystran.rotation", "kind": "module", "doc": "<p>Define rotation utilities.</p>\n"}, {"fullname": "pystran.rotation.rotmat3", "modulename": "pystran.rotation", "qualname": "rotmat3", "kind": "function", "doc": "<p>Compute a 3D rotation matrix from a rotation vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rotvec</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.rotation.rotate", "modulename": "pystran.rotation", "qualname": "rotate", "kind": "function", "doc": "<p>Rotate a 3D vector <code>v</code> by an angle about the unit vector defined by joints <code>i</code>\nand <code>j</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">angleindegrees</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.section", "modulename": "pystran.section", "kind": "module", "doc": "<p>Define section dictionaries.</p>\n\n<p>A section defines material properties, geometrical properties, such as the\nsecond moment of area, and also orientation of the cross section profile.</p>\n"}, {"fullname": "pystran.section.truss_section", "modulename": "pystran.section", "qualname": "truss_section", "kind": "function", "doc": "<p>Define truss section.</p>\n\n<ul>\n<li><code>E</code>= Young's modulus,</li>\n<li><code>A</code>= cross-sectional area,</li>\n<li><code>rho</code>= mass density.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">E</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">A</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">rho</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.section.beam_2d_section", "modulename": "pystran.section", "qualname": "beam_2d_section", "kind": "function", "doc": "<p>Define 2d beam section.</p>\n\n<ul>\n<li><code>E</code>= Young's modulus,</li>\n<li><code>A</code>= cross-sectional area,</li>\n<li><code>I</code>= central moment of inertia of the cross-section about the <code>y</code>\ncoordinate axis (i.e. the axis perpendicular to the plane of the bending, <code>x-z</code>).</li>\n<li><code>rho</code>= mass density.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">E</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">A</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">I</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">rho</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.section.beam_3d_section", "modulename": "pystran.section", "qualname": "beam_3d_section", "kind": "function", "doc": "<p>Define 3d beam section.</p>\n\n<ul>\n<li><code>E</code>, <code>G</code>= Young's and shear modulus,</li>\n<li><code>rho</code>= mass density,</li>\n<li><code>A</code>= cross-sectional area,</li>\n<li><code>Ix</code>= central moment of inertia of the cross-section about the local <code>x</code>.</li>\n<li><code>Iy</code>, <code>Iz</code>= central moment of inertia of the cross-section about the local <code>y</code> and local <code>z</code>\ncoordinate axis,</li>\n<li><code>J</code>= St Venant torsion constant.</li>\n<li><code>xz_vector</code>= vector that lies in the local <code>x</code> and <code>z</code> coordinate plane.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">name</span>,</span><span class=\"param\">\t<span class=\"n\">E</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">G</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">A</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">Ix</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">Iy</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">Iz</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">J</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">rho</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">xz_vector</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.section.circular_tube", "modulename": "pystran.section", "qualname": "circular_tube", "kind": "function", "doc": "<p>Returns the area, moments of inertia and torsion constant for a hollow circle (tube).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">innerradius</span>, </span><span class=\"param\"><span class=\"n\">outerradius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.section.i_beam", "modulename": "pystran.section", "qualname": "i_beam", "kind": "function", "doc": "<p>Returns the area, moments of inertia and torsion constant for an I-beam.</p>\n\n<p>The axis parallel to the flanges is <code>y</code>, the axis parallel to the web is <code>z</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">H</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">tf</span>, </span><span class=\"param\"><span class=\"n\">tw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.section.square_tube", "modulename": "pystran.section", "qualname": "square_tube", "kind": "function", "doc": "<p>Returns the area, moments of inertia and torsion constant for a square tube.</p>\n\n<p>The axis parallel to the <code>B</code> dimension is <code>y</code>, the axis parallel to the <code>H</code>\ndimension is <code>z</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">H</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">th</span>, </span><span class=\"param\"><span class=\"n\">tb</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.section.rectangle", "modulename": "pystran.section", "qualname": "rectangle", "kind": "function", "doc": "<p>Returns the area, moments of inertia and torsion constant for a solid\nrectangular section.</p>\n\n<p>The axis parallel to the <code>B</code> dimension is <code>y</code>, the axis parallel to the <code>H</code>\ndimension is <code>z</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">H</span>, </span><span class=\"param\"><span class=\"n\">B</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.truss", "modulename": "pystran.truss", "kind": "module", "doc": "<p>Define truss mechanical quantities.</p>\n"}, {"fullname": "pystran.truss.truss_stiffness", "modulename": "pystran.truss", "qualname": "truss_stiffness", "kind": "function", "doc": "<p>Compute truss stiffness matrix.</p>\n\n<p>The axial stiffness matrix is computed as $K = EA B^T B h$. Here $B$ is the\nstretch-displacement matrix, computed by <code>truss_strain_displacement</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_x</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">E</span>, </span><span class=\"param\"><span class=\"n\">A</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.truss.truss_2d_mass", "modulename": "pystran.truss", "qualname": "truss_2d_mass", "kind": "function", "doc": "<p>Compute 2d truss mass matrix.</p>\n\n<p>The mass matrix is consistent, which means that it is computed as discrete\nform of the kinetic energy of the element,</p>\n\n<p>$\\int \\rho A \\left(\\dot u \\cdot \\dot u +  \\dot w \\cdot \\dot w\\right)dx$</p>\n\n<p>where $\\dot u$ and $\\dot w$ are the velocities in the $x$ and $z$ directions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_x</span>, </span><span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">A</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.truss.truss_3d_mass", "modulename": "pystran.truss", "qualname": "truss_3d_mass", "kind": "function", "doc": "<p>Compute 3d truss mass matrix.</p>\n\n<p>The mass matrix is consistent, which means that it is computed as discrete\nform of the kinetic energy of the element,</p>\n\n<p>$\\int \\rho A \\left(\\dot u \\cdot \\dot u +  \\dot v \\cdot \\dot v +  \\dot w \\cdot \\dot w\\right)dx$</p>\n\n<p>where $\\dot u$, $\\dot v$, and $\\dot w$ are the velocities in the $x$, $y$, and $z$ directions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_x</span>, </span><span class=\"param\"><span class=\"n\">e_y</span>, </span><span class=\"param\"><span class=\"n\">e_z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">A</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.truss.truss_strain_displacement", "modulename": "pystran.truss", "qualname": "truss_strain_displacement", "kind": "function", "doc": "<p>Compute truss strain-displacement matrix.</p>\n\n<p>The axial strain is computed as $\\varepsilon = B u$, using the strain\ndisplacement matrix $B$ and the displacement vector $u$.</p>\n\n<p>The dimension of the strain-displacement matrix depends on the number of\nspace dimensions. The vector <code>e_x</code> is the unit vector along the truss\nmember, so it could have one, two, or three components.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e_x</span>, </span><span class=\"param\"><span class=\"n\">h</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.truss.assemble_stiffness", "modulename": "pystran.truss", "qualname": "assemble_stiffness", "kind": "function", "doc": "<p>Assemble truss stiffness matrix.</p>\n\n<ul>\n<li><code>Kg</code> is the global stiffness matrix,</li>\n<li><code>member</code> is the truss member,</li>\n<li><code>i</code>, <code>j</code> are the joints.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Kg</span>, </span><span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.truss.assemble_mass", "modulename": "pystran.truss", "qualname": "assemble_mass", "kind": "function", "doc": "<p>Assemble truss mass matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Mg</span>, </span><span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pystran.truss.truss_axial_force", "modulename": "pystran.truss", "qualname": "truss_axial_force", "kind": "function", "doc": "<p>Compute truss axial force based on the displacements stored at the joints.</p>\n\n<p>The force is computed as $N = EA B U$, where $B$ is the strain-displacement\nmatrix (computed by <code>truss_strain_displacement</code>), $U$ is the displacement\nvector (so that $\\varepsilon  = BU$ is the axial strain), and $EA$ is the\naxial stiffness.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">member</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();